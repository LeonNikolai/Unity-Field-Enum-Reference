using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
namespace FieldRef;
[Generator]
public class EnumRefGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is ClassDeclarationSyntax,
                transform: (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.found)
            .Select((t, _) => t.data);
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static ((ClassDeclarationSyntax, INamedTypeSymbol[]) data, bool found)
        GetClassDeclarationForSourceGen(
            GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not { } classSymbol)
            return ((null, null), false);

        var symbols = new List<INamedTypeSymbol>();
        foreach (var attributeData in classSymbol.GetAttributes())
        {
            if (attributeData.AttributeClass?.ToDisplayString() == "Leon.FieldRef.FieldEnumAttribute")
            {
                var arg = attributeData.ConstructorArguments[0];
                if (arg.Value is INamedTypeSymbol typeSymbol)
                {
                    symbols.Add(typeSymbol);
                }
            }
        }

        if (symbols.Count == 0) return ((null, null), false);
        return ((classDeclarationSyntax, symbols.ToArray()), true);
    }

    void GenerateCode(SourceProductionContext context,
        (ClassDeclarationSyntax classDecl, INamedTypeSymbol[] fieldTypes) input)
    {
        var classDecl = input.classDecl;
        var className = classDecl.Identifier.Text;
        bool isPartial = classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        var sb = new StringBuilder();
        using var sw = new StringWriter(sb);
        using var writer = new IndentedTextWriter(sw);
        
        writer.WriteLine("// <auto-generated/>");
        if (isPartial)
        {
            GenerateAsPartial(input, writer, className, classDecl);
        }
        else
        {
            GenerateAsExtension(input, writer, className, classDecl);
        }

        // Add Source File
        context.AddSource($"FieldRef.{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void GenerateAsPartial((ClassDeclarationSyntax classDecl, INamedTypeSymbol[] fieldTypes) input,
        IndentedTextWriter writer, string className, ClassDeclarationSyntax classDecl)
    {
        WriteNamespaceAndNesting(writer, classDecl);
        foreach (var fieldType in input.fieldTypes)
        {
            var fieldSymbols = FieldSymbols(classDecl, fieldType);
            var (fieldTypeDisplay,enumName) = FormatName(fieldType);
            
            // partial class header
            writer.WriteLine($"public partial class {className}");
            writer.WriteLine("{");
            writer.Indent++;

            // Enum definition 
            writer.WriteLine($"public enum {enumName}");
            writer.WriteLine("{");
            writer.Indent++;
            int i = 0;
            foreach (var (name, _) in fieldSymbols)
            {
                writer.WriteLine($"{name} = {(i++).ToString()},");
            }
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();

            // GetRef method
            writer.WriteLine($"public ref {fieldTypeDisplay} GetFieldRef({enumName} target)");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("switch (target)");
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var (name, _) in fieldSymbols)
            {
                writer.WriteLine($"case {enumName}.{name}: return ref this.{name};");
            }
            writer.WriteLine("default: throw new System.ArgumentOutOfRangeException(nameof(target));");
            writer.Indent--;
            writer.WriteLine("}");
            writer.Indent--;
            writer.WriteLine("}");
            
            // Close class
            writer.Indent--;
            writer.WriteLine("}");
        }
        CloseNamespaceAndNesting(writer, classDecl);
    }

    private static List<(string name, string value)> FieldSymbols(ClassDeclarationSyntax classDecl, INamedTypeSymbol fieldType)
    {
        return classDecl.Members
            .OfType<FieldDeclarationSyntax>()
            .Where(field =>
                field.Modifiers.Any(SyntaxKind.PublicKeyword) &&
                !field.Modifiers.Any(SyntaxKind.StaticKeyword) &&
                field.Declaration.Type.ToString() == fieldType.ToDisplayString())
            .SelectMany(field =>
                field.Declaration.Variables.Select(v =>
                    (name: v.Identifier.Text, value: v.Initializer?.Value.ToString())))
            .ToList();
    }

    private static void WriteNamespaceAndNesting(IndentedTextWriter writer, ClassDeclarationSyntax classDecl)
    {
        var stack = new Stack<SyntaxNode>();
        var parent = classDecl.Parent;
        while (parent is not null && parent is not CompilationUnitSyntax)
        {
            stack.Push(parent);
            parent = parent.Parent;
        }

        while (stack.Count > 0)
        {
            var node = stack.Pop();
            switch (node)
            {
                case NamespaceDeclarationSyntax ns:
                    writer.WriteLine($"namespace {ns.Name}");
                    writer.WriteLine("{");
                    writer.Indent++;
                    break;
                case ClassDeclarationSyntax cls:
                    writer.WriteLine($"public partial class {cls.Identifier.Text}");
                    writer.WriteLine("{");
                    writer.Indent++;
                    break;
            }
        }
    }

    private static void CloseNamespaceAndNesting(IndentedTextWriter writer, ClassDeclarationSyntax classDecl)
    {
        var parent = classDecl.Parent;
        while (parent is not null && parent is not CompilationUnitSyntax)
        {
            writer.Indent--;
            writer.WriteLine("}");
            parent = parent.Parent;
        }
    }
    private static void GenerateAsExtension((ClassDeclarationSyntax classDecl, INamedTypeSymbol[] fieldTypes) input,
        IndentedTextWriter writer, string className, ClassDeclarationSyntax classDecl)
    {
        // Open Namespace
        writer.WriteLine("namespace Leon.FieldRef");
        writer.WriteLine("{");
        writer.Indent++;

        // Open Class
        writer.WriteLine($"public static partial class {className}Extensions");
        writer.WriteLine("{");
        writer.Indent++;
        // Generate ref methods and enums for fields
        foreach (var fieldType in input.fieldTypes)
        {
            var fieldSymbols = FieldSymbols(classDecl, fieldType);
            var (fieldTypeDisplay,enumName) = FormatName(fieldType);
            // Enum definition
            writer.WriteLine($"public enum {enumName}");
            writer.WriteLine("{");
            writer.Indent++;
            var i = 0;
            foreach (var (name, _) in fieldSymbols)
            {
                writer.WriteLine($"{name} = {(i++).ToString()},");
            }
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();

            // GetRef method
            writer.WriteLine(
                $"public static ref {fieldTypeDisplay} GetFieldRef(this {className} self, {enumName} target)");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("switch (target)");
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var (name, _) in fieldSymbols)
            {
                writer.WriteLine($"case {enumName}.{name}: return ref self.{name};");
            }

            writer.WriteLine("default: throw new System.ArgumentOutOfRangeException(nameof(target));");
            writer.Indent--;
            writer.WriteLine("}");
            writer.Indent--;
            writer.WriteLine("}");
        }

        // Close Class
        writer.Indent--;
        writer.WriteLine("}");

        // Close Namespace
        writer.Indent--;
        writer.WriteLine("}");
    }

    private static (string name,string enumName) FormatName(INamedTypeSymbol fieldType)
    {
        string name = fieldType.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
        return (name, $"FieldRef_{name}");
    }
}