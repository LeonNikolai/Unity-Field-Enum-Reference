using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
namespace FieldRefGenerator;
[Generator]
public class FieldRefGenerator : IIncrementalGenerator
{
    // Naming and formating
    private const string FileHeaderPrefix = "// <auto-generated/>";
    private const string AttributeName = "FieldRef.FieldRefAttribute";
    private const string NonPartialClassOutputNamespace = "FieldRef.Generated";
    private const string GetRefMethodName = "GetFieldRef";
    private static string GetNonPartialClassName(string className) => $"{className}Extension";
    private static string GetEnumName(string typeName) => $"FieldRef_{typeName}";
    private static string GetFieldTypeName(INamedTypeSymbol fieldType)
    {
        return fieldType.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
    }
    
    //Logic
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is ClassDeclarationSyntax,
                transform: (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.found)
            .Select((t, _) => t.data);
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static ((ClassDeclarationSyntax, INamedTypeSymbol[]) data, bool found)
        GetClassDeclarationForSourceGen(
            GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not { } classSymbol)
            return ((null, null), false);

        var symbols = new List<INamedTypeSymbol>();
        foreach (var attributeData in classSymbol.GetAttributes())
        {
            if (attributeData.AttributeClass?.ToDisplayString() == AttributeName)
            {
                var arg = attributeData.ConstructorArguments[0];
                if (arg.Value is INamedTypeSymbol typeSymbol)
                {
                    symbols.Add(typeSymbol);
                }
            }
        }

        if (symbols.Count == 0) return ((null, null), false);
        return ((classDeclarationSyntax, symbols.ToArray()), true);
    }

    void GenerateCode(SourceProductionContext context,
        (ClassDeclarationSyntax classDecl, INamedTypeSymbol[] fieldTypes) input)
    {
        var classDecl = input.classDecl;
        var className = classDecl.Identifier.Text;
        bool isPartial = classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        var sb = new StringBuilder();
        using var sw = new StringWriter(sb);
        using var writer = new IndentedTextWriter(sw);
        
        writer.WriteLine(FileHeaderPrefix);
        if (isPartial)
        {
            GenerateAsPartial(input, writer, className, classDecl);
        }
        else
        {
            GenerateAsExtension(input, writer, className, classDecl);
        }

        // Add Source File
        context.AddSource($"FieldRef.{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void GenerateAsPartial((ClassDeclarationSyntax classDecl, INamedTypeSymbol[] fieldTypes) input,
        IndentedTextWriter writer, string className, ClassDeclarationSyntax classDecl)
    {
        WriteNamespaceAndNesting(writer, classDecl);
        foreach (var fieldType in input.fieldTypes)
        {
            var fieldSymbols = FieldSymbols(classDecl, fieldType);
            var fieldTypeDisplay = GetFieldTypeName(fieldType);
            var enumName = GetEnumName(fieldTypeDisplay);
            
            // partial class header
            writer.WriteLine($"public partial class {className}");
            writer.WriteLine("{");
            writer.Indent++;

            if (fieldSymbols.fields.Length > 0)
            {
                // Enum definition 
                writer.WriteLine($"public enum {enumName}");
                writer.WriteLine("{");
                writer.Indent++;
                int i = 0;
                foreach (var name in fieldSymbols.fields)
                {
                    writer.WriteLine($"{name} = {(i++).ToString()},");
                }
                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLine();

                // GetRef method
                writer.WriteLine($"public ref {fieldTypeDisplay} {GetRefMethodName}({enumName} target)");
                writer.WriteLine("{");
                writer.Indent++;
                writer.WriteLine("switch (target)");
                writer.WriteLine("{");
                writer.Indent++;
                foreach (var name in fieldSymbols.fields)
                {
                    writer.WriteLine($"case {enumName}.{name}: return ref this.{name};");
                }
                writer.WriteLine("default: throw new System.ArgumentOutOfRangeException(nameof(target));");
                writer.Indent--;
                writer.WriteLine("}");
                writer.Indent--;
                writer.WriteLine("}");
            }

            if (fieldSymbols.staticFields.Length > 0)
            {
                GenerateStaticMethodsAndEnum(writer, className, enumName, fieldSymbols.staticFields, fieldTypeDisplay);
            }
            
            // Close class
            writer.Indent--;
            writer.WriteLine("}");
        }
        CloseNamespaceAndNesting(writer, classDecl);
    }

    private static (string[] fields, string[] staticFields) FieldSymbols(ClassDeclarationSyntax classDecl, INamedTypeSymbol fieldType)
    {
        var fields = classDecl.Members.OfType<FieldDeclarationSyntax>().Where(
            e => e.Modifiers.Any(SyntaxKind.PublicKeyword) &&
                 e.Declaration.Type.ToString() == fieldType.ToDisplayString());
        var fieldDeclarationSyntaxes = fields as FieldDeclarationSyntax[] ?? fields.ToArray();
        int fieldCount = fieldDeclarationSyntaxes.Count();
        int staticFieldCount = 0;
        int normalFieldCount = 0;
        bool[] isStaticField = new bool[fieldCount];
        for (int i = 0; i < fieldCount; i++)
        {
            var fieldSymbol = fieldDeclarationSyntaxes[i];
            bool isStatic = fieldSymbol.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword));
            isStaticField[i] = isStatic;
            if (isStatic)
            {
                staticFieldCount+= fieldSymbol.Declaration.Variables.Count;
            }
            else
            {
                normalFieldCount+= fieldSymbol.Declaration.Variables.Count;
            }
        }

        string[] staticFields = new string[staticFieldCount];
        string[] fieldNames = new string[normalFieldCount];
        normalFieldCount = 0;
        staticFieldCount = 0;
        for (int i = 0; i < fieldCount; i++)
        {
            if (isStaticField[i])
            {
                foreach (var variable in fieldDeclarationSyntaxes[i].Declaration.Variables)
                {
                    staticFields[staticFieldCount] = variable.Identifier.ToString();
                    staticFieldCount++;
                }
            }
            else
            {
                foreach (var variable in fieldDeclarationSyntaxes[i].Declaration.Variables)
                {
                    fieldNames[normalFieldCount] = variable.Identifier.ToString();
                    normalFieldCount++;
                }
            }
        }

        return (fieldNames, staticFields);
    }

    private static void WriteNamespaceAndNesting(IndentedTextWriter writer, ClassDeclarationSyntax classDecl)
    {
        var stack = new Stack<SyntaxNode>();
        var parent = classDecl.Parent;
        while (parent is not null && parent is not CompilationUnitSyntax)
        {
            stack.Push(parent);
            parent = parent.Parent;
        }

        while (stack.Count > 0)
        {
            var node = stack.Pop();
            switch (node)
            {
                case NamespaceDeclarationSyntax ns:
                    writer.WriteLine($"namespace {ns.Name}");
                    writer.WriteLine("{");
                    writer.Indent++;
                    break;
                case ClassDeclarationSyntax cls:
                    writer.WriteLine($"public partial class {cls.Identifier.Text}");
                    writer.WriteLine("{");
                    writer.Indent++;
                    break;
            }
        }
    }

    private static void CloseNamespaceAndNesting(IndentedTextWriter writer, ClassDeclarationSyntax classDecl)
    {
        var parent = classDecl.Parent;
        while (parent is not null && parent is not CompilationUnitSyntax)
        {
            writer.Indent--;
            writer.WriteLine("}");
            parent = parent.Parent;
        }
    }
    private static void GenerateAsExtension((ClassDeclarationSyntax classDecl, INamedTypeSymbol[] fieldTypes) input,
        IndentedTextWriter writer, string className, ClassDeclarationSyntax classDecl)
    {
        // Open Namespace
        writer.WriteLine($"namespace {NonPartialClassOutputNamespace}");
        writer.WriteLine("{");
        writer.Indent++;

        // Open Class
        writer.WriteLine($"public static partial class {GetNonPartialClassName(className)}");
        writer.WriteLine("{");
        writer.Indent++;
        // Generate ref methods and enums for fields
        foreach (var fieldType in input.fieldTypes)
        {
            var fieldSymbols = FieldSymbols(classDecl, fieldType);
            var fieldTypeDisplay = GetFieldTypeName(fieldType);
            var enumName = GetEnumName(fieldTypeDisplay);

            if (fieldSymbols.fields.Length != 0)
            {
                // Enum definition
                writer.WriteLine($"public enum {enumName}");
                writer.WriteLine("{");
                writer.Indent++;
                var i = 0;
                foreach (var name in fieldSymbols.fields)
                {
                    writer.WriteLine($"{name} = {(i++).ToString()},");
                }
                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLine();
            
            
                // GetRef method
                writer.WriteLine(
                    $"public static ref {fieldTypeDisplay} {GetRefMethodName}(this {className} self, {enumName} target)");
                writer.WriteLine("{");
                writer.Indent++;
                writer.WriteLine("switch (target)");
                writer.WriteLine("{");
                writer.Indent++;
                foreach (var name in fieldSymbols.fields)
                {
                    writer.WriteLine($"case {enumName}.{name}: return ref self.{name};");
                }
                writer.WriteLine("default: throw new System.ArgumentOutOfRangeException(nameof(target));");
                writer.Indent--;
                writer.WriteLine("}");
                writer.Indent--;
                writer.WriteLine("}");
            }

            if (fieldSymbols.staticFields.Length > 0)
            {
                GenerateStaticMethodsAndEnum(writer, className, enumName, fieldSymbols.staticFields, fieldTypeDisplay);
            }
        }

        // Close Class
        writer.Indent--;
        writer.WriteLine("}");

        // Close Namespace
        writer.Indent--;
        writer.WriteLine("}");
    }

    private static void GenerateStaticMethodsAndEnum(IndentedTextWriter writer, string className, string enumName,
        string[] fieldSymbols, string fieldTypeDisplay)
    {
        // Enum definition STATIC
        writer.WriteLine($"public enum Static{enumName}");
        writer.WriteLine("{");
        writer.Indent++;
        var i = 0;
        foreach (var name in fieldSymbols)
        {
            writer.WriteLine($"{name} = {(i++).ToString()},");
        }
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();
                    
        // GetRef method Static
        writer.WriteLine($"public static ref {fieldTypeDisplay} {GetRefMethodName}(Static{enumName} target)");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("switch (target)");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var name in fieldSymbols)
        {
            writer.WriteLine($"case Static{enumName}.{name}: return ref {className}.{name};");
        }
        writer.WriteLine("default: throw new System.ArgumentOutOfRangeException(nameof(target));");
        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");
    }
}